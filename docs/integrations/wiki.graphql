# Controls the rate of traffic.
directive @rateLimit(
  # Number of occurrences allowed over duration.
  limit: Int! = 60

  # Number of seconds before limit is reset.
  duration: Int! = 60
) on OBJECT | FIELD_DEFINITION

directive @auth(
  requires: [String]
) on QUERY | FIELD_DEFINITION | ARGUMENT_DEFINITION

type SlackChannelQuery {
  list: [SlackChannel!]!
}

type SlackChannelMutation {
  add(name: String!, id: String!): DefaultResponse
  remove(id: String!): DefaultResponse
  toggleActivationState(ids: [String!]!, newState: Boolean): DefaultResponse
}

type SlackChannel {
  id: Int!
  name: String!
  channelId: String!
  enabled: Boolean!
}

# Queries for Analytics
type AnalyticsQuery {
  # Fetch list of Analytics providers and their configuration
  providers(
    # Return only active providers
    isEnabled: Boolean
  ): [AnalyticsProvider]
}

# Mutations for Analytics
type AnalyticsMutation {
  # Update a list of Analytics providers and their configuration
  updateProviders(
    # List of providers
    providers: [AnalyticsProviderInput]!
  ): DefaultResponse
}

# Analytics Provider
type AnalyticsProvider {
  # Is the provider active
  isEnabled: Boolean!

  # Unique identifier for this provider
  key: String!

  # List of configuration properties, formatted as stringified JSON objects
  props: [String]

  # Name of the provider
  title: String!

  # Short description of the provider
  description: String

  # Is the provider available for use
  isAvailable: Boolean

  # Path to the provider logo
  logo: String

  # Website of the provider
  website: String

  # Configuration values for this provider
  config: [KeyValuePair]
}

# Analytics Configuration Input
input AnalyticsProviderInput {
  # Is the provider active
  isEnabled: Boolean!

  # Unique identifier of the provider
  key: String!

  # Configuration values for this provider
  config: [KeyValuePairInput]
}

type AssetQuery {
  list(folderId: Int!, kind: AssetKind!): [AssetItem]
  folders(parentFolderId: Int!): [AssetFolder]
  assetRelations(assetId: Int!): AssetRelations
  assetFolderRelations(folderId: Int!): AssetRelations
}

type AssetMutation {
  createFolder(
    parentFolderId: Int!
    slug: String!
    name: String
  ): DefaultResponse
  renameAsset(id: Int!, filename: String!): DefaultResponse
  moveAsset(id: Int!, folderId: Int!): MoveAssetResponse
  deleteAsset(id: Int!): DefaultResponse
  deleteFolder(id: Int!): DefaultResponse
  flushTempUploads: DefaultResponse
  assetMigration: DefaultResponse
}

type AssetItem {
  id: Int!
  filename: String!
  ext: String!
  kind: AssetKind!
  mime: String!
  fileSize: Int!
  metadata: String
  createdAt: Date!
  updatedAt: Date!
  folder: AssetFolder
  author: User
}

type AssetFolder {
  id: Int!
  slug: String!
  name: String
}

type MoveAssetResponse {
  responseResult: ResponseStatus
  id: Int
  oldPath: String
  newPath: String
}

type AssetRelations {
  id: Int!
  pages: [Page]
  contentBlocks: [ContentBlock]
  knowledgeHubPublications: [KnowledgeHubPublication]
}

enum AssetKind {
  IMAGE
  BINARY
  ALL
}

type AuthenticationQuery {
  apiKeys: [AuthenticationApiKey]
  apiState: Boolean!
  strategies: [AuthenticationStrategy]
  activeStrategies(enabledOnly: Boolean): [AuthenticationActiveStrategy]
}

type AuthenticationMutation {
  createApiKey(
    name: String!
    expiration: String!
    fullAccess: Boolean!
    group: Int
  ): AuthenticationCreateApiKeyResponse
  login(
    username: String!
    password: String!
    strategy: String!
  ): AuthenticationLoginResponse
  loginTFA(
    continuationToken: String!
    securityCode: String!
    setup: Boolean
  ): AuthenticationLoginResponse
  loginChangePassword(
    continuationToken: String!
    newPassword: String!
  ): AuthenticationLoginResponse
  forgotPassword(email: String!): DefaultResponse
  register(
    email: String!
    password: String!
    name: String!
  ): AuthenticationRegisterResponse
  revokeApiKey(id: Int!): DefaultResponse
  setApiState(enabled: Boolean!): DefaultResponse
  updateStrategies(strategies: [AuthenticationStrategyInput]!): DefaultResponse
  resetGuestUser: DefaultResponse
}

type AuthenticationStrategy {
  key: String!
  props: [KeyValuePair]
  title: String!
  description: String
  isAvailable: Boolean
  useForm: Boolean!
  usernameType: String
  logo: String
  color: String
  website: String
  icon: String
}

type AuthenticationActiveStrategy {
  key: String!
  strategy: AuthenticationStrategy!
  displayName: String!
  order: Int!
  isEnabled: Boolean!
  config: [KeyValuePair]
  selfRegistration: Boolean!
  domainWhitelist: [String]!
  autoEnrollGroups: [Int]!
}

type AuthenticationLoginResponse {
  responseResult: ResponseStatus
  jwt: String
  mustChangePwd: Boolean
  mustProvideTFA: Boolean
  mustSetupTFA: Boolean
  continuationToken: String
  redirect: String
  tfaQRImage: String
}

type AuthenticationRegisterResponse {
  responseResult: ResponseStatus
  jwt: String
}

input AuthenticationStrategyInput {
  key: String!
  strategyKey: String!
  config: [KeyValuePairInput]
  displayName: String!
  order: Int!
  isEnabled: Boolean!
  selfRegistration: Boolean!
  domainWhitelist: [String]!
  autoEnrollGroups: [Int]!
}

type AuthenticationApiKey {
  id: Int!
  name: String!
  keyShort: String!
  expiration: Date!
  createdAt: Date!
  updatedAt: Date!
  isRevoked: Boolean!
}

type AuthenticationCreateApiKeyResponse {
  responseResult: ResponseStatus
  key: String
}

type BookmarkQuery {
  list: [BookmarksListItem!]!
  isPageBookmarked(page_id: Int!): IsBookmarkedResponse!
}

type BookmarkMutation {
  bookmark(page_id: Int!): BookmarkResponse!
  deleteBookmark(page_id: Int!): BookmarkResponse!
}

type BookmarksListItem {
  id: Int!
  localeCode: String
  path: String
  title: String
  description: String
  createdAt: Date!
  updatedAt: Date!
}

type IsBookmarkedResponse {
  isBookmarked: Boolean!
}

type BookmarkResponse {
  responseResult: ResponseStatus
}

type CachedAnswersQuery {
  list(
    limit: Int
    offset: Int
    search: String
    includePageCount: Boolean
    orderByDirection: PageOrderByDirection
  ): CachedAnswerListResult
}

type CachedAnswersMutation {
  removeFromCache(id: Int!): DefaultResponse!
  cleanCache: DefaultResponse!
}

type CachedAnswer {
  id: Int!
  conversationContent: ConversationContentListItem!
  pages: [Page!]!
  createdAt: Date!
}

type CachedAnswerListResult {
  items: [CachedAnswer!]!
  totalCount: Int
}

type CommentQuery {
  providers: [CommentProvider]
  list(locale: String!, path: String!): [CommentPost]!
  single(id: Int!): CommentPost
}

type CommentMutation {
  updateProviders(providers: [CommentProviderInput]): DefaultResponse
  create(
    pageId: Int!
    replyTo: Int
    content: String!
    guestName: String
    guestEmail: String
  ): CommentCreateResponse
  update(id: Int!, content: String!): CommentUpdateResponse
  delete(id: Int!): DefaultResponse
}

type CommentProvider {
  isEnabled: Boolean!
  key: String!
  title: String!
  description: String
  logo: String
  website: String
  isAvailable: Boolean
  config: [KeyValuePair]
}

input CommentProviderInput {
  isEnabled: Boolean!
  key: String!
  config: [KeyValuePairInput]
}

type CommentPost {
  id: Int!
  content: String!
  render: String!
  authorId: Int!
  authorName: String!
  authorEmail: String!
  authorIP: String!
  createdAt: Date!
  updatedAt: Date!
}

type CommentCreateResponse {
  responseResult: ResponseStatus
  id: Int
}

type CommentUpdateResponse {
  responseResult: ResponseStatus
  render: String
}

# Generic Key Value Pair
type KeyValuePair {
  key: String!
  value: String!
}

# General Key Value Pair Input
input KeyValuePairInput {
  key: String!
  value: String!
}

# Generic Mutation Response
type DefaultResponse {
  responseResult: ResponseStatus
  id: Int
}

# Mutation Status
type ResponseStatus {
  succeeded: Boolean!
  errorCode: Int!
  slug: String!
  message: String
}

# Query (Read)
type Query {
  allowedSlackChannels: SlackChannelQuery
  analytics: AnalyticsQuery
  assets: AssetQuery
  authentication: AuthenticationQuery
  bookmarks: BookmarkQuery
  cachedAnswers: CachedAnswersQuery
  comments: CommentQuery
  compliance: ComplianceQuery
  contentBlocks: ContentBlocksQuery
  contribute: ContributeQuery
  conversationContent: ConversationContentQuery
  countryGuides: CountryGuidesQuery
  defaultOwners: DefaultOwnerQuery
  departments: DepartmentQuery
  directories: DirectoryQuery
  domainAllowlists: DomainAllowlistQuery
  editorComments: EditorCommentsQuery
  engineMapping: EngineMappingQuery
  faq: FaqQuery
  googleDocs: GoogleDocQuery
  googleSheets: GoogleSheetQuery
  groups: GroupQuery
  jiraTicket: TicketQuery
  knowledgeHub: KnowledgeHubQuery
  lastVisitedPages: LastVisitedPagesQuery
  localization: LocalizationQuery
  mail: MailQuery
  maintenanceCycle: MaintenanceCycleQuery
  navigation: NavigationQuery
  notification: NotificationQuery
  pages: PageQuery
  pageDrafts: PageDraftQuery
  pageFeedbacks: PageFeedbacksQuery
  rendering: RenderingQuery
  ruleUpdate: RuleUpdateQuery
  scraperContents: ScraperContentsQuery
  scraperSites: ScraperSitesQuery
  search: SearchQuery
  site: SiteQuery
  storage: StorageQuery
  system: SystemQuery
  dataTables: DataTablesQuery
  tags: TagQuery
  tagCategory: TagCategoryQuery
  tagLibraries: TagLibrariesQuery
  theming: ThemingQuery
  users: UserQuery
  userSettings: UserSettingsQuery
}

# Mutations (Create, Update, Delete)
type Mutation {
  allowedSlackChannels: SlackChannelMutation
  analytics: AnalyticsMutation
  assets: AssetMutation
  authentication: AuthenticationMutation
  bookmarks: BookmarkMutation
  cachedAnswers: CachedAnswersMutation
  comments: CommentMutation
  compliance: ComplianceMutation
  contentBlocks: ContentBlocksMutation
  conversationContent: ConversationContentMutation
  countryGuides: CountryGuidesMutation
  defaultOwners: DefaultOwnerMutation
  departments: DepartmentMutation
  directories: DirectoryMutation
  domainAllowlists: DomainAllowlistMutation
  editorComments: EditorCommentsMutation
  engineMapping: EngineMappingMutation
  faq: FaqMutation
  googleDocs: GoogleDocMutation
  googleSheets: GoogleSheetMutation
  groups: GroupMutation
  knowledgeHub: KnowledgeHubMutation
  localization: LocalizationMutation
  mail: MailMutation
  maintenanceCycle: MaintenanceCycleMutation
  navigation: NavigationMutation
  pages: PageMutation
  pageDrafts: PageDraftMutation
  pageFeedbacks: PageFeedbacksMutation
  rendering: RenderingMutation
  ruleUpdate: RuleUpdateMutation
  scraperSites: ScraperSitesMutation
  search: SearchMutation
  site: SiteMutation
  storage: StorageMutation
  system: SystemMutation
  dataTables: DataTablesMutation
  tagCategory: TagCategoryMutation
  tagLibraries: TagLibrariesMutation
  theming: ThemingMutation
  users: UserMutation
  userSettings: UserSettingsMutation
}

type Compliance {
  id: Int!
  title: String!
  tags: [Tag]
  effectiveDate: String!
  ctaText: String
  ctaLink: String
  mediaDesktop: String
  mediaMobile: String
  content: String
  pageTitle: String
  createdAt: String!
  updatedAt: String!
  pageId: Int!
}

input ComplianceInput {
  effectiveDate: String!
  ctaText: String
  ctaLink: String
  mediaDesktop: String!
  mediaMobile: String
  pageId: Int!
}

input ComplianceUpdateInput {
  id: Int!
  effectiveDate: String
  ctaText: String
  ctaLink: String
  mediaDesktop: String
  mediaMobile: String
  pageId: Int
}

type Tag {
  tag: String!
  categories: [String]
}

type ComplianceResponse {
  responseResult: ResponseStatus!
  compliance: Compliance
}

type CompliancePage {
  id: Int!
  title: String!
}

type ComplianceList {
  pages: [Compliance!]!
  cursor: String
}

type ComplianceQuery {
  list(cursor: String, limit: Int, search: String): ComplianceList!
  get: ComplianceResponse
  listUnusedPages: [CompliancePage]
}

type ComplianceMutation {
  create(input: ComplianceInput!): ComplianceResponse!
  update(input: ComplianceUpdateInput!): ComplianceResponse!
  delete(id: Int!): ComplianceResponse!
  fetchComplianceContent(siteIds: [Int!]): DefaultResponse
}

type ContentBlocksQuery {
  all: [ContentBlock!]!
  getById(id: Int!): ContentBlock!
  getLinkedPagesById(id: Int!): [ContentBlockPage]!
}

type ContentBlock {
  id: Int!
  name: String!
  content: String!
  createdAt: Date!
  updatedAt: Date!
  pagesCount: Int!
}

type ContentBlockPage {
  id: Int!
  path: String!
  title: String!
}

type ContentBlocksMutation {
  create(name: String!, content: String!): DefaultResponse!
  update(id: Int!, name: String!, content: String!): DefaultResponse!
  delete(id: Int!): DefaultResponse!
  deleteMany(ids: [Int!]!): DefaultResponse!
}

type ContributeQuery {
  contributors: [ContributeContributor]
}

type ContributeContributor {
  id: String!
  source: String!
  name: String!
  joined: Date!
  website: String
  twitter: String
  avatar: String
}

type ConversationContentQuery {
  list(
    pageLimit: Int
    totalLimit: Int
    offset: Int
    search: String
    includePageCount: Boolean
    score: Int
    platforms: [Platform]
    orderBy: String
    orderByDirection: ConversationContentOrderByDirection
    feedbackGroups: [String]
    profileTypes: [String]
    dateRange: [String]
    userGroups: [Int]
    conversationId: String
  ): ConversationContentListResult!
  listFeedback(
    limit: Int
    offset: Int
    search: String
    includePageCount: Boolean
    platforms: [Platform]
    statuses: [Status]
    orderBy: ConversationFeedbackOrderBy
    orderByDirection: ConversationContentOrderByDirection
    groups: [Int]
    userGroups: [Int]
    dateRange: [String]
    feedbackGroups: [String]
    profileTypes: [String]
  ): FeedBackListResult
  listByNotAnsweredQuestions(
    reviewed: Boolean
    orderBy: ConversationContentOrderBy
    orderByDirection: ConversationContentOrderByDirection
  ): [ConversationContentListItem!]!
}

type ConversationContentMutation {
  changeReviewed(id: Int!, reviewed: Boolean!): ConversationContentListItem!
  changeStatus(
    id: Int!
    status: String!
    reviewed: Boolean!
  ): ConversationContentListItem!
  resolveFeedback(
    id: Int!
    reviewed: Boolean!
    status: String!
    resolution: String
    shouldSendEmail: Boolean
  ): DefaultResponse!
  resolveFeedbacks(
    ids: [Int!]!
    reviewed: Boolean!
    status: String!
    resolution: String
    shouldSendEmail: Boolean
  ): DefaultResponse!
  assignGroup(feedbackId: Int!, groupId: Int!): DefaultResponse!
  assignGroupMany(feedbackIds: [Int!]!, groupId: Int!): DefaultResponse!
  addToCache(id: Int!): DefaultResponse!
  removeFromCache(id: Int!): DefaultResponse!
}

enum Status {
  OPEN
  IN_PROGRESS
  DISMISSED
  RESOLVED
  PENDING
}

type ConversationContentListItem {
  id: Int!
  conversation_id: Int!
  question: String
  answer: String
  score: Int
  feedback: String
  reviewed: Boolean
  status: Status
  resolution: String
  created_at: Date!
  isCached: Boolean
  aiType: String
  gptType: String
  feedback_group: String
  profile_type: String
  isAgent: Boolean
  agentName: String
  agentEmail: String
  metadata: String
  pages: [PageMinimal!]
  user_email: String
  user_type: String
}

type ConversationContentFeedbackListItem {
  id: Int!
  user_email: String
  user_type: String
  conversation_id: Int
  question: String
  answer: String
  score: Int
  feedback: String
  reviewed: Boolean
  status: Status
  resolution: String
  created_at: Date!
  feedback_opened_at: Date
  feedback_total_response_time: String
  feedback_close_time: String
  organization_id: Int
  isCached: Boolean
  assignedGroup: GroupMinimal
  pages: [Page]
  feedback_group: String
  tags: [String]
  countries: [String]
  profile_type: String
}

enum ConversationContentOrderBy {
  CREATED
  ID
  PATH
  TITLE
  UPDATED
}

enum ConversationFeedbackOrderBy {
  CREATED
  PLATFORM
  QUESTION
  FEEDBACK
  FEEDBACK_GROUP
  STATUS
  GROUP
  RESPONSE_TIME
  CLOSE_TIME
  SCORE
}

enum ConversationContentOrderByDirection {
  ASC
  DESC
}

type ConversationContentListResult {
  items: [ConversationContentListItem!]!
  totalCount: Int
  message: String
}

enum Platform {
  DEEL_ADMIN
  DEEL_USER
  EXTENSION_USER
  DEEL_SLACK
  ZAPIER_USER
  SLACK_EXTERNAL_USER
  SUPPORT_USER
  DEEL_WEB
  DEEL_EVERYWHERE
}

enum FeedbackStatus {
  DISMISSED
  IN_PROGRESS
  OPEN
  PENDING
  RESOLVED
}

type FeedBackListResult {
  items: [ConversationContentFeedbackListItem!]!
  totalCount: Int
}

type CountryGuidesCountry {
  id: Int!
  name: String!
  isoCode: String!
  audiencesEnabledFor: [Int]!
  contractTypesEnabledFor: [String]!
  fieldvalues: [CountryGuidesCountryField]
}

type CountryGuidesCountryResponse {
  responseResult: ResponseStatus!
  country: CountryGuidesCountry
}

type CountryGuidesFieldResponse {
  responseResult: ResponseStatus!
  field: CountryGuidesField
}

input LinkValue {
  label: String
  newTab: Boolean
}

input CountryGuidesCountryFieldsUpdate {
  fieldName: String!
  fieldType: String!
  value: String
  metadata: LinkValue
  isDeleted: Boolean
  categoryId: Int
  fieldId: Int
  position: Int
}

input CountryGuidesCountryFieldsInsert {
  fieldName: String!
  fieldType: String!
  audienceId: Int!
  contractType: String
  categoryId: Int
  position: Int
}

type CountryGuidesField {
  id: Int!
  name: String!
  fieldType: CountryGuidesFieldType!
  audienceId: Int!
  audience: PageTag
  categoryId: Int
  category: KnowledgeHubCategory!
  contractType: String
}

enum CountryGuidesFieldType {
  TEXT_VALUE
  LINK
  DATABASE_VALUE_ID
  CONTENT_BLOCK_ID
}

type CountryGuidesCountryField {
  fieldId: Int!
  fieldName: String!
  fieldType: CountryGuidesFieldType!
  value: String
  valueData: ValueData
  audienceId: Int
  contractType: String
  categoryId: Int
  position: Int
}

type ValueData {
  name: String
  content: String
  key: String
  value: String
  label: String
  newTab: Boolean
}

type CountryGuidesQuery {
  fetchFields(
    country: Int
    audience: Int
    contractType: String
    category: Int
  ): [CountryGuidesField]
  fetchCountryGuides: [CountryGuidesCountry]
  listCountries: [CountryGuidesCountry]
  listCountryFields(countryId: Int!): [CountryGuidesCountryField]
}

type CountryGuidesMutation {
  createCountry(
    name: String!
    isoCode: String!
    fieldValues: [CountryGuidesCountryFieldsInsert]
    template: Int
  ): CountryGuidesCountryResponse
  createField(
    name: String!
    fieldType: CountryGuidesFieldType!
    countryId: Int!
    audienceId: Int!
    contractType: String
    categoryId: Int
    position: Int
  ): CountryGuidesFieldResponse
  updateGuides(
    countryId: Int!
    name: String
    isoCode: String
    audienceId: Int!
    contractType: String
    fieldValues: [CountryGuidesCountryFieldsUpdate]
  ): DefaultResponse
  deleteFields(fieldIds: [Int!]): DefaultResponse
  updateGuidesPublicationState(
    countryId: Int!
    audienceId: Int!
    contractType: String
    isPublished: Boolean!
  ): DefaultResponse
  deleteGuides(countryId: Int!): DefaultResponse
}

type DefaultOwnerQuery {
  list: [DefaultOwner]
  single(id: Int!): DefaultOwner
}

type DefaultOwnerMutation {
  create(groupId: Int!, path: String!): DefaultOwnerResponse
  createMultiplePathDefaultOwner(
    groupId: Int!
    pathes: [String!]!
  ): ResponseStatus
  update(id: Int!, path: String, groupId: Int): DefaultResponse
  delete(id: Int!): DefaultResponse
}

type DefaultOwnerResponse {
  responseResult: ResponseStatus!
  defaultOwner: DefaultOwner
}

type DefaultOwner {
  id: Int!
  path: String!
  group: Group!
  createdAt: Date!
  updatedAt: Date!
}

# -----------------------------------------------
# QUERIES
# -----------------------------------------------
type DepartmentQuery {
  list: [DepartmentMinimal]
  single(id: Int!): Department
}

# -----------------------------------------------
# MUTATIONS
# -----------------------------------------------
type DepartmentMutation {
  create(name: String!): DepartmentResponse
  update(departmentId: Int!, name: String!): DepartmentResponse
  setGroups(departmentId: Int!, groups: [Int!]!): DefaultResponse
  delete(departmentId: Int!): DefaultResponse
}

type DepartmentMinimal {
  id: Int!
  name: String!
  createdAt: Date!
  updatedAt: Date
  groupsCount: Int!
}

type Department {
  id: Int!
  name: String!
  createdAt: Date!
  updatedAt: Date
  groups: [GroupMinimal]!
}

type DepartmentResponse {
  responseResult: ResponseStatus!
  department: DepartmentMinimal
}

type DirectoryQuery {
  list(orderBy: String): [Directory]
  single(path: String!): Directory
  pathDirectory(pagePath: String!): Directory
  templates(path: String!): [String]
  tags(path: String!): [String]
}

type DirectoryMutation {
  insert(directorySettings: DirectoryInput!): DirectoryResponse
  insertMultiple(directorySettings: [DirectoryInput!]!): DirectoryResponse
  create(directoryInput: DirectoryInput!): DirectoryResponse
  update(directorySettings: DirectoryInput!): DirectoryResponse
  delete(path: String!): DirectoryResponse
  upsert(directorySettings: DirectoryInput!): DirectoryResponse
  upsertMultipleDirectories(
    paths: [String!]!
    defaultPublish: Boolean
    defaultPrivate: Boolean
    preventScraping: Boolean
    hideFeedback: Boolean
  ): DirectoryResponse
}

type DirectoryResponse {
  responseResult: ResponseStatus!
  directory: Directory
}

type Directory {
  id: Int!
  path: String!
  defaultPublish: Boolean!
  defaultPrivate: Boolean!
  preventScraping: Boolean!
  hideFeedback: Boolean!
  templates: [String]!
  tags: [String]!
}

input DirectoryInput {
  path: String!
  defaultPublish: Boolean
  defaultPrivate: Boolean
  preventScraping: Boolean
  hideFeedback: Boolean
  templates: [String]!
  tags: [String]!
}

type APIKey {
  id: Int!
  name: String!
}

type DomainAllowlist {
  id: Int!
  domain: String!
  apiKey: APIKey!
  createdAt: String!
}

input DomainAllowlistInput {
  domain: String!
  apiKeyId: Int!
}

type DomainAllowlistResponse {
  responseResult: ResponseStatus!
}

type DomainAllowlistQuery {
  list: [DomainAllowlist!]!
}

type DomainAllowlistMutation {
  create(input: DomainAllowlistInput!): DomainAllowlistResponse!
  delete(id: Int!): DomainAllowlistResponse!
}

type EditorCommentsQuery {
  list(pageId: Int!): [EditorComment!]!
}

type EditorComment {
  id: Int!
  content: String!
  creatorId: Int!
  pageId: Int!
  threadId: Int
  editorCommentId: String!
  creatorName: String!
  creatorPicture: String
  createdAt: String!
  updatedAt: String!
}

input EditorCommentPartialInput {
  id: Int
  creatorId: Int
  content: String!
  pageId: Int
  editorCommentId: String!
  resolvedAt: String
  resolvedById: Int
}

type EditorCommentsMutation {
  create(
    content: String!
    pageId: Int!
    editorCommentId: String!
  ): DefaultResponse!
  resolve(id: Int!): DefaultResponse!
}

type EngineMappingQuery {
  byId(id: Int!): EngineMapping
  byRuleName(ruleName: String!): [EngineMapping]!
}

type EngineMappingMutation {
  createEngineMapping(
    path: String!
    fieldKey: String!
    fieldValue: String!
    ruleName: String!
  ): EngineMappingResponse
  updateEngineMapping(
    id: Int!
    path: String
    fieldKey: String
    fieldValue: String
    ruleName: String
  ): EngineMappingResponse
  deleteEngineMapping(id: Int!): EngineMappingResponse
}

type EngineMapping {
  id: Int!
  path: String!
  fieldKey: String!
  fieldValue: String!
  ruleName: String!
  createdAt: String
  updatedAt: String
}

type EngineMappingResponse {
  success: Boolean!
  message: String
  engineMapping: EngineMapping
}

type FaqQuery {
  pagesByUserType(
    user_type: String
    user_country: String
    search_term: String
    filter_out_user_type: String
    limit: Int
  ): [PageByUserType]!
  list(user_type: String!): [FAQ]!
  tagsByUserType(
    user_type: String
    filter_out_user_type: String
  ): [TagByUserType]!
}

type FaqMutation {
  create(
    user_type: String!
    tag: String
    page_id: Int
    order: Int
  ): DefaultResponse
  update(id: Int!, order: Int): DefaultResponse
  delete(id: Int!): DefaultResponse
  updateOrders(faqs: [FaqOrderUpdateInput!]!): DefaultResponse
}

type FAQ {
  id: Int!
  user_type: String!
  tag: String
  page_id: Int
  order: Int
  title: String
  updatedAt: String
  createdAt: String
}

input FaqOrderUpdateInput {
  id: Int!
  order: Int!
}

type PageByUserType {
  pageId: Int!
  title: String!
}

type TagByUserType {
  id: Int!
  tag: String!
}

type GoogleDocQuery {
  listGoogleDocs: [GoogleDoc]
}

type GoogleDocMutation {
  addGoogleDoc(input: GoogleDocInput!): GoogleDocResponse
  updateGoogleDoc(input: GoogleDocUpdateInput!): GoogleDocResponse
  deleteGoogleDoc(id: ID!): GoogleDocResponse
  resyncGoogleDoc(id: ID!): GoogleDocResponse
}

type GoogleDoc {
  id: ID!
  title: String!
  gDocId: String!
  path: String!
  context: String
  status: String!
  statusDetail: String
  createdAt: String
  updatedAt: String
}

input Doc {
  url: String!
  path: String
}

input GoogleDocInput {
  id: ID
  gDocUrls: [Doc!]!
  title: String
  path: String!
  context: String
  isPublished: Boolean
}

input GoogleDocUpdateInput {
  gDocId: String!
  id: ID!
  title: String!
  path: String!
  context: String
}

type ProcessingResult {
  id: Int!
  url: String!
  completed: Boolean!
  reason: String
}

type GoogleDocResponse {
  responseResult: ResponseStatus!
  googleDoc: GoogleDoc
  processingResult: [ProcessingResult]
}

type GoogleSheet {
  id: Int!
  title: String!
  gSheetId: String!
  range: String!
  groupByColumn: String!
  path: String!
  context: String
  createdAt: Date!
  updatedAt: Date!
}

input GoogleSheetInput {
  url: String!
  range: String
  path: String!
  groupByColumn: String!
  isPublished: Boolean!
  context: String
}

input GoogleSheetUpdateInput {
  id: Int!
  gSheetId: String!
  range: String
  path: String!
  groupByColumn: String!
  context: String
}

type GoogleSheetResponse {
  responseResult: ResponseStatus!
  googleSheet: GoogleSheet
}

type GoogleSheetMutation {
  add(input: GoogleSheetInput!): GoogleSheetResponse!
  update(input: GoogleSheetUpdateInput!): GoogleSheetResponse!
  delete(id: Int!): GoogleSheetResponse!
}

type GoogleSheetQuery {
  list: [GoogleSheet!]!
}

type GroupQuery {
  paginatedList(
    limit: Int!
    offset: Int
    search: String
    includePageCount: Boolean
    orderBy: String
    orderByDirection: String
  ): GroupListResult
  list(filter: String, orderBy: String): [GroupMinimal]
  single(id: Int!): Group
  searchStartsWith(query: String!): [GroupMinimal]
}

type GroupMutation {
  create(name: String!): GroupResponse
  update(
    id: Int!
    name: String!
    redirectOnLogin: String!
    permissions: [String]!
    pageRules: [PageRuleInput]!
  ): DefaultResponse
  delete(id: Int!, altGroupId: Int!): DefaultResponse
  assignUser(groupId: Int!, userId: Int!): DefaultResponse
  bulkUserAssignment(groupId: Int!, emails: [String!]!): BulkAssignmentResponse
  unassignUser(groupId: Int!, userId: Int!): DefaultResponse
}

type GroupResponse {
  responseResult: ResponseStatus!
  group: Group
}

type UserIdAndEmail {
  id: String!
  email: String!
}

type BulkAssignmentResponse {
  responseResult: ResponseStatus!
  assigned: [UserIdAndEmail]!
  alreadyAssigned: [String]!
  invalidEmails: [String]!
  emailsWithoutAccount: [String]!
}

type GroupMinimal {
  id: Int!
  name: String!
  isSystem: Boolean!
  userCount: Int
  createdAt: Date!
  updatedAt: Date!
  permissions: [String]!
}

type Group {
  id: Int!
  name: String!
  isSystem: Boolean!
  redirectOnLogin: String
  permissions: [String]!
  pageRules: [PageRule]
  users: [UserMinimal]
  createdAt: Date!
  updatedAt: Date!
}

type PageRule {
  id: String!
  deny: Boolean!
  match: PageRuleMatch!
  roles: [String]!
  path: String!
  locales: [String]!
}

input PageRuleInput {
  id: String!
  deny: Boolean!
  match: PageRuleMatch!
  roles: [String]!
  path: String!
  locales: [String]!
}

enum PageRuleMatch {
  START
  EXACT
  END
  REGEX
  TAG
}

type GroupListResult {
  items: [GroupMinimal!]!
  totalCount: Int
}

type TicketQuery {
  logs(ticketId: Int!): [JiraTicketChangeLogs]
}

type JiraTicket {
  id: Int!
  status: String!
  url: String
  key: String
  assignee: String
  createdAt: Date
  updatedAt: Date
  dueDate: String
}

type JiraTicketChangeLogs {
  id: Int!
  status: String!
  author: String
  date: Date!
}

type KnowledgeHubCategory {
  id: Int!
  name: String!
  slug: String
  icon: String!
  position: Int!
  published: Boolean!
  independent: Boolean
  tags: [PageTag!]!
}

type KnowledgeHubPublicationRuleItem {
  id: Int!
  ruleId: Int!
  tagId: Int!
  rowId: Int!
}

type AssetInfo {
  id: Int!
  path: String!
}

type KnowledgeHubPublicationRule {
  id: Int!
  name: String!
  items: [KnowledgeHubPublicationRuleItem!]
  assets: [AssetInfo]
}

type KnowledgeHubRuleResponse {
  responseResult: ResponseStatus!
  rule: KnowledgeHubPublicationRule
}

type KnowledgeHubPage {
  id: Int!
  page: PageMinimal!
  picture: String!
  createdAt: Date!
  effectiveDate: Date
  pageId: Int!
  published: Boolean!
}

type KnowledgeHubPublication {
  id: Int!
  name: String!
  quickActions: [String!]
  page: Page
  rule: KnowledgeHubPublicationRule
  picture: String!
  createdAt: Date!
  effectiveDate: Date!
  pageId: Int
  ruleId: Int
  categoryId: Int!
}

type KnowledgeHubPost {
  id: Int!
  title: String!
  description: String!
  featuredImage: String!
  quickActions: [String!]
  createdAt: Date!
  updatedAt: Date!
  isPublished: Boolean
  category: KnowledgeHubCategory!
  tags: [KnowledgeHubFilterTag!]
}

type KnowledgeHubArticle {
  id: Int!
  title: String!
  description: String!
  featuredImage: String!
  createdAt: Date!
  updatedAt: Date!
  render: String!
  isPublished: Boolean
  toc: [String!]!
  tags: [KnowledgeHubFilterTag!]!
  type: String!
  effectiveDate: Date
}

type KnowledgeHubFilterItem {
  id: Int!
  title: String!
}

type KnowledgeHubFilterTag {
  id: Int!
  title: String!
}

type KnowledgeHubFilters {
  country: [KnowledgeHubFilterItem!]
  contractType: [KnowledgeHubFilterItem!]
}

type KnowledgeHubPublicationResponse {
  responseResult: ResponseStatus!
  publication: KnowledgeHubPublication
}

type KnowledgeHubPageResponse {
  responseResult: ResponseStatus!
  page: KnowledgeHubPage
}

type KnowledgeHubCategoryResponse {
  responseResult: ResponseStatus
  category: KnowledgeHubCategory
}

type PaginatedknowledgeHubPublications {
  cursor: Int
  publications: [KnowledgeHubPublication]!
}

type PaginatedknowledgeHubPages {
  cursor: String
  pages: [KnowledgeHubPage]!
}

type PaginatedKnowledgeHubPosts {
  cursor: String
  items: [KnowledgeHubPost]!
}

type PaginatedKnowledgeHubArticles {
  cursor: String
  items: [KnowledgeHubArticle]!
}

type KnowledgeHubCountryInfo {
  id: Int!
  name: String!
  isoCode: String!
  countryTagId: Int
}

input PartialRuleItem {
  rowId: Int!
  tagId: Int!
}

input AssetInfoInput {
  id: Int!
}

type KnowledgeHubQuery {
  fetchCategories: [KnowledgeHubCategory]!
  fetchCategoriesV2: [KnowledgeHubCategory]!
  fetchRules: [KnowledgeHubPublicationRule]!
  fetchRule(ruleId: Int!): KnowledgeHubPublicationRule!
  fetchFilters: KnowledgeHubFilters!

  # This query will fetch posts from wiki-gpt
  fetchPosts(
    category: Int
    userType: String
    contractTypeId: Int
    country: Int
    isPublished: Boolean
    cursor: String
  ): PaginatedKnowledgeHubPosts!

  # This query will fetch articles for v2 from wiki-gpt
  fetchArticles(
    audience: String!
    country: Int!
    category: Int!
    contractType: String
  ): PaginatedKnowledgeHubArticles!
  fetchCountryGuides(country: String): KnowledgeHubCountryInfo!
  fetchPages(
    search: String
    cursor: String
    limit: Int
    tags: [String!]
    isPublished: Boolean
  ): PaginatedknowledgeHubPages!
  fetchPublications(
    categoryId: Int
    search: String
    cursor: Int
    limit: Int
  ): PaginatedknowledgeHubPublications
  listUnusedPages: [PageMinimal]!
}

type KnowledgeHubMutation {
  createCategory(
    name: String!
    icon: String!
    slug: String
    independent: Boolean
    isV2: Boolean
    tags: [Int!]
  ): KnowledgeHubCategoryResponse
  updateCategoriesPositions(
    orderedCategories: [UpdatedPositionType!]!
    isV2: Boolean
  ): DefaultResponse!
  updateCategory(
    id: Int!
    name: String
    slug: String
    icon: String
    published: Boolean
    independent: Boolean
    isV2: Boolean
    tags: [Int!]
  ): KnowledgeHubCategoryResponse
  deleteCategory(id: Int!): DefaultResponse!
  deleteCategoryV2(id: Int!): DefaultResponse!
  createPublication(
    name: String!
    quickActions: [String!]
    category: Int!
    effectiveDate: String
    picture: Int!
    page: Int
    rule: Int
  ): KnowledgeHubPublicationResponse
  addPage(
    page: Int!
    effectiveDate: Date
    picture: Int!
    published: Boolean
  ): KnowledgeHubPageResponse
  updatePagePublicationState(
    published: Boolean!
    page: Int!
  ): KnowledgeHubPageResponse
  createRule(
    name: String!
    items: [PartialRuleItem!]!
    assets: [AssetInfoInput!]
  ): KnowledgeHubRuleResponse
  updateRule(
    name: String!
    items: [PartialRuleItem!]!
    ruleId: Int!
    assets: [AssetInfoInput!]
  ): KnowledgeHubRuleResponse
  deleteRule(id: Int!): DefaultResponse
  updatePublication(
    id: Int!
    name: String
    quickActions: [String!]
    category: Int
    effectiveDate: String
    picture: Int
    page: Int
    rule: Int
  ): KnowledgeHubPublicationResponse
  updatePage(
    id: Int!
    effectiveDate: Date
    picture: Int
    page: Int!
    published: Boolean!
  ): DefaultResponse
  deletePublication(id: Int!): DefaultResponse!
  deletePage(id: Int!): DefaultResponse!
}

type LastVisitedPagesQuery {
  list(limit: Int): [LastVisitedPage]
}

type LastVisitedPage {
  id: String!
  title: String!
  description: String!
  path: String!
  locale: String!
  visitedAt: Date!
}

type LocalizationQuery {
  locales: [LocalizationLocale]
  config: LocalizationConfig
  translations(locale: String!, namespace: String!): [Translation]
}

type LocalizationMutation {
  downloadLocale(locale: String!): DefaultResponse
  updateLocale(
    locale: String!
    autoUpdate: Boolean!
    namespacing: Boolean!
    namespaces: [String]!
  ): DefaultResponse
}

type LocalizationLocale {
  availability: Int!
  code: String!
  createdAt: Date!
  installDate: Date
  isInstalled: Boolean!
  isRTL: Boolean!
  name: String!
  nativeName: String!
  updatedAt: Date!
}

type LocalizationConfig {
  locale: String!
  autoUpdate: Boolean!
  namespacing: Boolean!
  namespaces: [String]!
}

type Translation {
  key: String!
  value: String!
}

type MailQuery {
  config: MailConfig
}

type MailMutation {
  sendTest(recipientEmail: String!): DefaultResponse
  updateConfig(
    senderName: String!
    senderEmail: String!
    host: String!
    port: Int!
    name: String!
    secure: Boolean!
    verifySSL: Boolean!
    user: String!
    pass: String!
    useDKIM: Boolean!
    dkimDomainName: String!
    dkimKeySelector: String!
    dkimPrivateKey: String!
  ): DefaultResponse
}

type MailConfig {
  senderName: String
  senderEmail: String
  host: String
  port: Int
  name: String
  secure: Boolean
  verifySSL: Boolean
  user: String
  pass: String
  useDKIM: Boolean
  dkimDomainName: String
  dkimKeySelector: String
  dkimPrivateKey: String
}

type MaintenanceCycleQuery {
  list(filter: String): [MaintenanceCycleMinimalMutations]
  single(pageId: Int!): MaintenanceCycleMinimal
  default: DefaultMaintenanceResponse
}

type MaintenanceCycleMutation {
  create(name: String!): MaintenanceCycleMinimalMutations
  update(
    pageId: Int!
    cycleInterval: Int
    status: String
  ): MaintenanceCycleMinimalMutations
  updateMass(
    pageIds: [Int]!
    status: MaintenanceStatus
    lastCycleDate: Date
    cycleInterval: Int
  ): ResponseStatus
  updateByOwner(
    pageId: Int!
    cycleInterval: Int
    status: String
  ): MaintenanceCycleMinimalMutations
  updateDefault(
    cycleInterval: Int
    pageRules: [CyclePageRuleInput]
  ): DefaultMaintenanceResponse
  updateAfterExecution(pageId: Int!): MaintenanceCycleMinimalMutations
  delete(id: Int!): DefaultResponse
}

enum MaintenanceStatus {
  VERIFIED
  IN_PROGRESS
  VERIFICATION_REQUIRED
}

type MaintenanceCycle {
  id: Int!
  pageId: Int!
  lastCycleDate: Date
  cycleInterval: Int
  nextCycleDate: Date
  pageRules: [CyclePageRule]
  status: MaintenanceStatus
  createdAt: Date!
  updatedAt: Date!
}

type MaintenanceCycleMinimal {
  id: Int!
  pageId: Int!
  status: MaintenanceStatus
  lastCycleDate: Date
  cycleInterval: Int
  nextCycleDate: Date
}

type MaintenanceCycleMinimalMutations {
  id: Int!
  pageId: Int!
  status: MaintenanceStatus
  lastCycleDate: Date
  cycleInterval: Int
  nextCycleDate: Date
  success: Boolean
}

type DefaultMaintenanceResponse {
  cycleInterval: Int
  pageRules: [CyclePageRule]
}

type CyclePageRule {
  id: String!
  deny: Boolean!
  match: PageRuleMatch!
  path: String!
}

input CyclePageRuleInput {
  id: String!
  deny: Boolean!
  match: PageRuleMatch!
  path: String!
}

enum CyclePageRuleMatch {
  START
  EXACT
}

type NavigationQuery {
  tree: [NavigationTree]!
  config: NavigationConfig!
}

type NavigationMutation {
  updateTree(tree: [NavigationTreeInput]!): DefaultResponse
  updateConfig(mode: NavigationMode!): DefaultResponse
}

type NavigationTree {
  locale: String!
  items: [NavigationItem]!
}

input NavigationTreeInput {
  locale: String!
  items: [NavigationItemInput]!
}

type NavigationItem {
  id: String!
  kind: String!
  label: String
  icon: String
  targetType: String
  target: String
  visibilityMode: String
  visibilityGroups: [Int]
}

input NavigationItemInput {
  id: String!
  kind: String!
  label: String
  icon: String
  targetType: String
  target: String
  visibilityMode: String
  visibilityGroups: [Int]
}

type NavigationConfig {
  mode: NavigationMode!
}

enum NavigationMode {
  NONE
  TREE
  MIXED
  STATIC
}

type NotificationQuery {
  list: [Notification]
  pendingCount: Int!
}

type NotificationActor {
  id: Int!
  name: String!
}

type NotificationPage {
  id: Int!
  path: String!
}

type Notification {
  id: Int!
  message: String
  actor: NotificationActor
  page: NotificationPage
  viewedAt: String
  createdAt: String!
  event: String
}

type PageQuery {
  history(
    id: Int!
    offsetPage: Int
    offsetSize: Int
    isAgreement: Boolean
  ): PageHistoryResult
  version(pageId: Int!, versionId: Int!): PageVersion
  search(
    query: String!
    path: String
    locale: String
    limit: Int
  ): PageSearchResponse!
  list(
    limit: Int
    orderBy: PageOrderBy
    orderByDirection: PageOrderByDirection
    tags: [String!]
    tagLibrary: Int
    locale: String
    creatorId: Int
    authorId: Int
    offset: Int
    search: String
    publicationState: Boolean
    privateState: Boolean
    count: Boolean
    maintenanceInterval: [Int]
    isTagsLogicAnd: Boolean
    ids: [Int!]
  ): PageListResult!
  listAiGenerated(
    limit: Int
    orderByDirection: PageOrderByDirection
    search: String
    isPublished: Boolean
    cursor: String
  ): AiPageListResult!
  listFolders(path: String, limit: Int): [folderListItem!]!
  listPages(path: String, limit: Int): [PageListItem!]!
  searchPagesByTagLibrary(tagLibrary: Int): [PageListItem!]!
  listByGroups(
    limit: Int
    orderBy: PageOrderBy
    orderByDirection: PageOrderByDirection
    locale: String
    search: String
    offset: Int
    count: Boolean
    selectedStatuses: [String!]
    groupId: Int
  ): PageListResult!
  single(
    id: Int!
    checkPublishState: Boolean = true
    optimizeMarkup: Boolean = false
    addWrapperStructure: Boolean = false
  ): Page
  singleByPath(
    path: String!
    locale: String!
    checkPublishState: Boolean = true
  ): Page
  singleExists(path: String!, locale: String!): Boolean!
  tags: [PageTag]!
  tagCategories: [TagCategory]!
  tagsAndCategories: [TagWithCategory]
  searchPagesByTagsAndCategories(
    team: [Int]
    knowledge: [Int]
    country: [Int]
    type: [Int]
    domain: [Int]
    query: String
    limit: Int
    offset: Int
  ): searchPagesByTagsAndCategoriesResponse
  searchTags(query: String!): [String]!
  tree(
    path: String
    parent: Int
    mode: PageTreeMode!
    locale: String!
    includeAncestors: Boolean
  ): [PageTreeItem]
  links(locale: String!): [PageLinkItem]
  checkGrammar(content: String!): [GrammarCorrection]!
  checkDuplicates(content: String!): [DuplicatesResult]!
  checkConflicts(id: Int!, checkoutDate: Date!): Boolean!
  conflictLatest(id: Int!): PageConflictLatest!
  privateAndShared: [PageListItem!]!
  views(pageId: Int!): [ViewAuthor!]!
  deletedList(
    limit: Int
    orderBy: PageOrderBy
    orderByDirection: PageOrderByDirection
    offset: Int
    search: String
    count: Boolean
    selectAll: Boolean
  ): PageQueryResult
  linkingPages(pageId: Int!): [linkingPage]!
  countByTags: [TagWithCount]!
  singlePageByTag(
    tag: String!
    optimizeMarkup: Boolean
    addWrapperStructure: Boolean
  ): SinglePageByTagResult
  searchPagesByTitle(query: String!): searchPagesByTitleResponse!
}

type PageMutation {
  create(
    content: String!
    description: String!
    featuredImage: Int
    editor: String!
    isPublished: Boolean!
    isPrivate: Boolean!
    preventScraping: Boolean!
    locale: String!
    path: String!
    publishEndDate: Date
    publishStartDate: Date
    scriptCss: String
    scriptJs: String
    tags: [String]!
    title: String!
    sharedUsers: [Int]
    sharedGroups: [Int]
    sharedDepartments: [Int]
    isAgreement: Boolean
    editorComments: [EditorCommentPartialInput]
  ): PageResponse
  update(
    id: Int!
    content: String
    description: String
    featuredImage: Int
    editor: String
    isPrivate: Boolean
    isPublished: Boolean
    preventScraping: Boolean
    locale: String
    path: String
    publishEndDate: Date
    publishStartDate: Date
    scriptCss: String
    scriptJs: String
    tags: [String]
    title: String
    sharedUsers: [Int]
    sharedGroups: [Int]
    sharedDepartments: [Int]
    isAgreement: Boolean
    editorComments: [EditorCommentPartialInput]
  ): PageResponse
  updateSettings(
    id: Int!
    isPrivate: Boolean
    isPublished: Boolean
    sharedUsers: [Int]
    sharedGroups: [Int]
    sharedDepartments: [Int]
  ): PageResponse
  scheduling(id: Int!, isPublished: Boolean): PageResponse
  schedulingMany(ids: [Int]!, isPublished: Boolean): PagesResponse
  convert(id: Int!, editor: String!): DefaultResponse
  move(
    id: Int!
    destinationPath: String!
    destinationLocale: String!
    tags: [String]
  ): DefaultResponse
  cloneFolder(folderPath: String!, destinationPath: String!): DefaultResponse
  moveFolders(paths: [String!]!, destinationPath: String!): DefaultResponse
  renameFolder(path: String, destinationPath: String!): DefaultResponse
  delete(id: Int!): DefaultResponse
  deleteMany(ids: [Int!]): DefaultResponse
  restoreMany(ids: [Int!]): DefaultResponse
  softDelete(id: Int, ids: [Int!]): DefaultResponse
  deleteTag(id: Int!): DefaultResponse
  updateTag(
    id: Int!
    tag: String!
    title: String!
    categories: [Int!]
    children: [Int!]
    enabledInFeedbacks: Boolean!
  ): DefaultResponse
  flushCache: DefaultResponse
  migrateToLocale(
    sourceLocale: String!
    targetLocale: String!
  ): PageMigrationResponse
  rebuildTree: DefaultResponse
  render(id: Int!): DefaultResponse
  renderWithLinks(id: Int!): DefaultResponse
  restore(pageId: Int!, versionId: Int!): DefaultResponse
  purgeHistory(olderThan: String!): DefaultResponse
  deletePageHistoryById(id: Int!, pageId: Int!): DefaultResponse
  assignOwner(pageId: Int!, groupId: Int!, userOwnerId: Int): DefaultResponse
  massAssignOwner(pageIds: [Int!]!, groupId: Int!): DefaultResponse
  addTags(pages: [Int!]!, tags: [String!]!): DefaultResponse
  removeTags(pages: [Int!]!, tags: [String!]): DefaultResponse
  updateHistoryVersion(
    versionId: Int!
    content: String!
    pageId: Int!
  ): UpdateHistoryResponse
  updateHistoryVersionDate(versionId: Int!, date: Date!): DefaultResponse
}

type PageResponse {
  responseResult: ResponseStatus!
  page: Page
}

type UpdateHistoryResponse {
  responseResult: ResponseStatus!
  render: String
}

type PagesResponse {
  responseResult: ResponseStatus!
  pages: [Page]
}

type PageMigrationResponse {
  responseResult: ResponseStatus!
  count: Int
}

type searchPagesByTagsAndCategoriesResponse {
  pages: [MinimalPage]
  count: Int
}

type MinimalPage {
  id: Int!
  path: String!
  title: String!
  description: String!
  lastEditorName: String!
  lastEditedAt: String!
  tags: [String]
  deletedAt: Date
  deletedBy: User
}

type searchPagesByTitleResponse {
  pages: [PageByTitle!]
  count: Int
}

type PageByTitle {
  id: Int!
  path: String!
  title: String!
  ancestors: [Int]
  isFolder: Boolean!
  pageId: Int
  parent: Int
}

type Page {
  id: Int!
  path: String!
  hash: String!
  title: String!
  description: String!
  isAgreement: Boolean!
  featuredImage: Int
  featuredImageUrl: String
  isPrivate: Boolean!
  isPublished: Boolean!
  preventScraping: Boolean!
  privateNS: String
  publishStartDate: Date!
  publishEndDate: Date!
  tags: [PageTag]!
  content: String!
  render: String
  toc: String
  contentType: String!
  createdAt: Date!
  updatedAt: Date!
  editor: String!
  locale: String!
  scriptCss: String
  scriptJs: String
  authorId: Int!
  authorName: String!
  authorEmail: String!
  creatorId: Int!
  creatorName: String!
  creatorEmail: String!
  owner_group_id: Int
  ownerGroupName: String
  userOwnerId: Int
  userOwnerName: String
  sharedUsers: [SharedUser]
  sharedGroups: [SharedGroup]
  sharedDepartments: [SharedDepartment]
  isMaintainablePage: Boolean
  themeCss: String
  deletedAt: Date
  deletedBy: User
  linkedPagesCount: Int
  maintenanceTickets: [JiraTicket]
  isPublishedInKnowledgeHub: Boolean
}

type SharedGroup {
  id: Int!
  name: String!
}

type SharedDepartment {
  id: Int!
  name: String!
}

type SharedUser {
  id: Int!
  name: String!
  email: String!
}

type PageMinimal {
  id: Int!
  title: String!
  path: String!
  tags: [PageTag!]
}

type PageTag {
  id: Int!
  tag: String!
  title: String
  enabledInFeedbacks: Boolean!
  createdAt: Date!
  updatedAt: Date!
  categories: [TagCategory]
  children: [TagsByCategory]
}

type TagCategory {
  id: Int!
  name: String!
  slug: String!
  published: Boolean!
  position: Int
}

type TagCategoryWithTags {
  id: Int!
  name: String!
  slug: String!
  published: Boolean!
  position: Int
  tags: [PageTag]
}

type TagWithCategory {
  id: Int!
  slug: String!
  name: String!
  tags: [PageTag]
}

type PageHistory {
  versionId: Int!
  versionDate: Date!
  authorId: Int!
  render: String
  authorName: String!
  actionType: String!
  valueBefore: String
  valueAfter: String
  trigger: String!
}

type TagWithCount {
  tag: String!
  pageTagsCount: Int!
}

type PageVersion {
  action: String!
  authorId: String!
  authorName: String!
  content: String!
  contentType: String!
  createdAt: Date!
  versionDate: Date!
  description: String!
  editor: String
  isPrivate: Boolean!
  isPublished: Boolean!
  preventScraping: Boolean!
  locale: String!
  pageId: Int!
  path: String!
  publishEndDate: Date!
  publishStartDate: Date!
  tags: [String]!
  title: String!
  versionId: Int!
  render: String
}

type PageHistoryResult {
  trail: [PageHistory]
  total: Int!
}

type PageSearchResponse {
  results: [PageSearchResult]!
  suggestions: [String]!
  totalHits: Int!
}

type PageSearchResult {
  id: String!
  title: String!
  description: String!
  path: String!
  locale: String!
}

type PageListItem {
  id: Int!
  path: String!
  locale: String!
  title: String
  description: String
  contentType: String!
  isPublished: Boolean!
  isPrivate: Boolean!
  isAgreement: Boolean!
  featuredImage: Int
  featuredImageUrl: String
  preventScraping: Boolean!
  privateNS: String
  createdAt: Date!
  updatedAt: Date!
  tags: [String]
  rate: Float
  maintenanceInterval: String
  maintenanceStatus: String
  ownerGroupName: String
  render: String
  deletedAt: Date
  deletedBy: User
  lastJiraTicketStatus: String
  lastTicketUrl: String
  lastTicketKey: String
  authorName: String
}

type PageTreeItem {
  id: Int!
  path: String!
  depth: Int!
  title: String!
  isPrivate: Boolean!
  isFolder: Boolean!
  privateNS: String
  parent: Int
  pageId: Int
  locale: String!
  isPublished: Boolean
  isPublishedInKnowledgeHub: Boolean
}

type PageLinkItem {
  id: Int!
  path: String!
  title: String!
  links: [String]!
}

type PageConflictLatest {
  id: Int!
  authorId: String!
  authorName: String!
  content: String!
  createdAt: Date!
  description: String!
  isPublished: Boolean!
  preventScraping: Boolean!
  locale: String!
  path: String!
  tags: [String]
  title: String!
  updatedAt: Date!
}

type folderListItem {
  path: String!
}

type GrammarCorrection {
  change_from: String!
  change_to: String!
  reason: String!
}

type DuplicatesResult {
  id: Int!
  title: String!
  chunks: [String]!
}

enum PageOrderBy {
  CREATED
  ID
  PATH
  TITLE
  UPDATED
  DELETED
}

enum PageOrderByDirection {
  ASC
  DESC
}

enum PageTreeMode {
  FOLDERS
  PAGES
  ALL
}

type PageListResult {
  items: [PageListItem!]!
  totalCount: Int
}

type AiPageListResult {
  items: [PageListItem!]!
  cursor: String
}

type ViewAuthor {
  id: Int!
  userId: Int!
  name: String!
  email: String!
  lastViewedAt: Date!
}

type linkingPage {
  id: Int!
  title: String!
}

type SinglePageByTagItem {
  id: Int!
  path: String!
  title: String!
  description: String
  createdAt: Date!
  updatedAt: Date!
  render: String
}

type SinglePageByTagResult {
  responseResult: ResponseStatus
  page: SinglePageByTagItem
}

# Add union type for different response types
union PageQueryResult = PageListResult | PageIdsResult

# Add new type for ID-only results
type PageIdsResult {
  ids: [Int]
  totalCount: Int
}

type PageDraftQuery {
  list(pageId: Int!): PageDraftListResult!
  single(id: Int!): PageDraftResponse
}

type PageDraftMutation {
  create(
    pageId: Int!
    title: String!
    description: String!
    featuredImage: Int
    content: String!
    publishStartDate: Date
    publishEndDate: Date
    scriptCss: String
    scriptJs: String
  ): PageDraftResponse
  update(
    id: Int!
    title: String!
    description: String!
    featuredImage: Int
    content: String!
    publishStartDate: Date
    publishEndDate: Date
    scriptCss: String
    scriptJs: String
  ): PageDraftResponse
  delete(id: Int!): DefaultResponse
  promote(id: Int!): PageResponse
}

type PageDraftResponse {
  responseResult: ResponseStatus!
  draft: PageDraft
}

type PageDraftListResult {
  responseResult: ResponseStatus!
  items: [PageDraftListItem!]
  totalCount: Int
}

type PageDraft {
  id: Int!
  title: String!
  description: String!
  pageId: Int!
  featuredImage: Int
  featuredImageUrl: String
  publishStartDate: Date
  publishEndDate: Date
  content: String!
  scriptCss: String
  scriptJs: String
  createdAt: Date!
  updatedAt: Date!
}

type PageDraftListItem {
  id: Int!
  title: String!
  description: String!
  pageId: Int!
  createdAt: Date!
  updatedAt: Date!
}

type PageFeedbacksQuery {
  getRate(pageId: Int!): PageRate
  list(pageId: Int): [FeedbackItem]
  listByGroups: [FeedbackItem]
}

type PageFeedbacksMutation {
  create(pageId: Int!, rate: Int!, feedback: String): DefaultResponse
  updateStatus(id: Int!, status: String!, resolution: String): DefaultResponse
}

type PageRate {
  id: Int!
  rate: Float
}

type FeedbackItem {
  id: Int
  rate: Float
  feedback: String!
  user: String!
  email: String
  updatedAt: Date!
  pageId: Int
  pagePath: String!
  pageLocale: String!
  pageName: String!
  pageDescription: String
  tags: [String]
  tagTitles: [String]
  tagIds: [Int]
  status: String!
  resolution: String
  authorEmail: String
  ticketKey: String
  ticketUrl: String
}

type ListFeedbackItem {
  id: Int
  rate: Float
  feedback: String!
  user: String!
  email: String!
  pagePath: String!
  updatedAt: Date!
}

type RenderingQuery {
  renderers(filter: String, orderBy: String): [Renderer]
}

type RenderingMutation {
  updateRenderers(renderers: [RendererInput]): DefaultResponse
}

type Renderer {
  isEnabled: Boolean!
  key: String!
  title: String!
  description: String
  icon: String
  dependsOn: String
  input: String
  output: String
  config: [KeyValuePair]
}

input RendererInput {
  isEnabled: Boolean!
  key: String!
  config: [KeyValuePairInput]
}

type RuleUpdateQuery {
  list: [RuleUpdate!]!
}

type RuleUpdateMutation {
  previewRuleUpdate(
    ruleId: Int!
    templatePageId: Int!
    additionalContext: String
  ): RulePreviewResponse
  promoteRule(
    ruleId: Int!
    title: String!
    templatePageId: Int!
    additionalContext: String
    updatedContent: String
  ): RuleUpdateResponse
  archiveRule(id: Int!): RuleUpdateResponse
}

type RuleUpdate {
  id: Int!
  name: String!
  status: String!
  pageId: Int
  pagePath: String
  createdAt: Date!
}

type RuleUpdateResponse {
  success: Boolean!
  message: String
  ruleUpdate: RuleUpdate
}

type RulePreviewResponse {
  success: Boolean!
  message: String
  preview: String
}

scalar Date

type ScraperContentsQuery {
  list(
    status: [ScraperContentStatus]
    pageLimit: Int
    pageCursor: String
    search: String
    countries: [String]
    states: [String]
    topics: [String]
    orderByDirection: ScraperContentOrderByDirection
    orderBy: String
    startDate: String
    endDate: String
  ): ScraperContentsListResult!
}

type ScraperContentsListItem {
  id: Int!
  topic: String
  url: String!
  country: String
  state: String
  status: ScraperContentStatus
  createdAt: Date!
  updatedAt: Date!
  aiContent: String!
  scraperSiteId: Int!
}

enum ScraperContentStatus {
  pending
  processed
  archived
  done
}

type ScraperContentsListResult {
  responseResult: ResponseStatus!
  items: [ScraperContentsListItem!]
  cursor: String
  totalCount: Int
}

enum ScraperContentOrderByDirection {
  ASC
  DESC
}

type ScraperSitesQuery {
  list(
    status: [ScraperSiteContentStatus]
    pageLimit: Int
    pageCursor: String
    search: String
    countries: [String]
    topics: [String]
    states: [String]
    orderByDirection: ScraperSitesOrderByDirection
    updatedAt: String
    orderBy: String
    startDate: String
    endDate: String
  ): ScraperSitesListResult!
  single(id: Int!): ScraperContents
}

type ScraperSitesMutation {
  create(
    topic: String
    url: String!
    country: String
    state: String
  ): ScraperSiteCreateResult
  previewUpdate(
    templatePageId: Int!
    contentUpdate: String!
    additionalContext: String
    relatedPageIds: [Int]
  ): ScraperContentPreviewResponse
  promote(
    title: String!
    updateId: Int!
    templatePageId: Int!
    updatedContent: String!
    relatedPageIds: [Int]
  ): ScraperContentPromotedResponse
  createNewPageFromAiWriter(
    title: String!
    templatePageId: Int!
    updatedContent: String!
    relatedPageIds: [Int]
    destinationFolder: String
  ): ScraperContentPromotedResponse
}

type ScraperSites {
  id: Int!
  topic: String
  url: String!
  country: String
  state: String
  createdAt: Date!
  updatedAt: Date!
}

type ScraperSitesListItem {
  id: Int!
  topic: String
  url: String!
  country: String
  state: String
  createdAt: Date!
  updatedAt: Date!
  hasAiContent: Boolean
}

type ScraperContentsItem {
  id: Int!
  scraperSiteId: Int!
  rawContent: String!
  aiContent: String
  status: ScraperSiteContentStatus
  pageId: Int
  createdAt: Date!
  updatedAt: Date!
}

type ScraperContents {
  site: ScraperSitesListItem
  content: [ScraperContentsItem]
}

enum ScraperSiteContentStatus {
  pending
  processed
  archived
  done
}

type ScraperSitesListResult {
  responseResult: ResponseStatus!
  items: [ScraperSitesListItem!]
  cursor: String
  totalCount: Int
}

type ScraperSiteCreateResult {
  responseResult: ResponseStatus!
  site: ScraperSites
}

type ScraperContentPreviewResponse {
  success: Boolean!
  message: String
  preview: String
  title: String
}

type ScraperContentPromotedResponse {
  success: Boolean!
  message: String
  pageId: Int
  pagePath: String
}

enum ScraperSitesOrderByDirection {
  ASC
  DESC
}

type SearchQuery {
  searchEngines(filter: String, orderBy: String): [SearchEngine]
}

type SearchMutation {
  updateSearchEngines(engines: [SearchEngineInput]): DefaultResponse
  rebuildIndex: DefaultResponse
}

type SearchEngine {
  isEnabled: Boolean!
  key: String!
  title: String!
  description: String
  logo: String
  website: String
  isAvailable: Boolean
  config: [KeyValuePair]
}

input SearchEngineInput {
  isEnabled: Boolean!
  key: String!
  config: [KeyValuePairInput]
}

type SiteQuery {
  config: SiteConfig
}

type SiteMutation {
  updateConfig(
    host: String
    title: String
    description: String
    robots: [String]
    analyticsService: String
    analyticsId: String
    company: String
    contentLicense: String
    footerOverride: String
    logoUrl: String
    pageExtensions: String
    authAutoLogin: Boolean
    authEnforce2FA: Boolean
    authHideLocal: Boolean
    authLoginBgUrl: String
    authJwtAudience: String
    authJwtExpiration: String
    authJwtRenewablePeriod: String
    editFab: Boolean
    editMenuBar: Boolean
    editMenuBtn: Boolean
    editMenuExternalBtn: Boolean
    editMenuExternalName: String
    editMenuExternalIcon: String
    editMenuExternalUrl: String
    featurePageRatings: Boolean
    featurePageComments: Boolean
    featureDeelWorkspaceComments: Boolean
    featurePersonalWikis: Boolean
    featureUseNATSForJobs: Boolean
    featureUseSimilaritySearch: Boolean
    featureSimilaritySearchEmails: [String]
    hideLoginButton: Boolean
    securityOpenRedirect: Boolean
    securityIframe: Boolean
    securityReferrerPolicy: Boolean
    securityTrustProxy: Boolean
    securitySRI: Boolean
    securityHSTS: Boolean
    securityHSTSDuration: Int
    securityCSP: Boolean
    securityCSPDirectives: String
    uploadMaxFileSize: Int
    uploadMaxFiles: Int
    uploadScanSVG: Boolean
    uploadForceDownload: Boolean
  ): DefaultResponse
}

type SiteConfig {
  host: String
  title: String
  description: String
  robots: [String]
  analyticsService: String
  analyticsId: String
  company: String
  contentLicense: String
  footerOverride: String
  logoUrl: String
  pageExtensions: String
  authAutoLogin: Boolean
  authEnforce2FA: Boolean
  authHideLocal: Boolean
  authLoginBgUrl: String
  authJwtAudience: String
  authJwtExpiration: String
  authJwtRenewablePeriod: String
  editFab: Boolean
  editMenuBar: Boolean
  editMenuBtn: Boolean
  editMenuExternalBtn: Boolean
  editMenuExternalName: String
  editMenuExternalIcon: String
  editMenuExternalUrl: String
  featurePageRatings: Boolean
  featurePageComments: Boolean
  featureDeelWorkspaceComments: Boolean
  featurePersonalWikis: Boolean
  hideLoginButton: Boolean
  securityOpenRedirect: Boolean
  securityIframe: Boolean
  securityReferrerPolicy: Boolean
  securityTrustProxy: Boolean
  securitySRI: Boolean
  securityHSTS: Boolean
  securityHSTSDuration: Int
  securityCSP: Boolean
  securityCSPDirectives: String
  uploadMaxFileSize: Int
  uploadMaxFiles: Int
  uploadScanSVG: Boolean
  uploadForceDownload: Boolean
}

type StorageQuery {
  targets: [StorageTarget]
  status: [StorageStatus]
}

type StorageMutation {
  updateTargets(targets: [StorageTargetInput]!): DefaultResponse
  executeAction(targetKey: String!, handler: String!): DefaultResponse
}

type StorageTarget {
  isAvailable: Boolean!
  isEnabled: Boolean!
  key: String!
  title: String!
  description: String
  logo: String
  website: String
  supportedModes: [String]
  mode: String
  hasSchedule: Boolean!
  syncInterval: String
  syncIntervalDefault: String
  config: [KeyValuePair]
  actions: [StorageTargetAction]
}

input StorageTargetInput {
  isEnabled: Boolean!
  key: String!
  mode: String!
  syncInterval: String
  config: [KeyValuePairInput]
}

type StorageStatus {
  key: String!
  title: String!
  status: String!
  message: String!
  lastAttempt: String!
}

type StorageTargetAction {
  handler: String!
  label: String!
  hint: String!
}

type SystemQuery {
  flags: [SystemFlag]
  info: SystemInfo
  extensions: [SystemExtension]
  exportStatus: SystemExportStatus
  geoData: [GeoCountryData]
}

type SystemMutation {
  updateFlags(flags: [SystemFlagInput]!): DefaultResponse
  resetTelemetryClientId: DefaultResponse
  setTelemetry(enabled: Boolean!): DefaultResponse
  performUpgrade: DefaultResponse
  importUsersFromV1(
    mongoDbConnString: String!
    groupMode: SystemImportUsersGroupMode!
  ): SystemImportUsersResponse
  setHTTPSRedirection(enabled: Boolean!): DefaultResponse
  renewHTTPSCertificate: DefaultResponse
  export(entities: [String]!, path: String!): DefaultResponse
}

type SystemFlag {
  key: String!
  value: Boolean!
}

input SystemFlagInput {
  key: String!
  value: Boolean!
}

type SystemInfo {
  configFile: String
  cpuCores: Int
  currentVersion: String
  dbHost: String
  dbType: String
  dbVersion: String
  groupsTotal: Int
  hostname: String
  httpPort: Int
  httpRedirection: Boolean
  httpsPort: Int
  latestVersion: String
  latestVersionReleaseDate: Date
  nodeVersion: String
  operatingSystem: String
  pagesTotal: Int
  deelWorkSpacePageTotal: Int
  feedbacksTotal: Int
  aliciaFeedbacksTotal: Int
  platform: String
  ramTotal: String
  sslDomain: String
  sslExpirationDate: Date
  sslProvider: String
  sslStatus: String
  sslSubscriberEmail: String
  tagsTotal: Int
  telemetry: Boolean
  telemetryClientId: String
  upgradeCapable: Boolean
  usersTotal: Int
  departmentsTotal: Int
  workingDirectory: String
}

enum SystemImportUsersGroupMode {
  MULTI
  SINGLE
  NONE
}

type SystemImportUsersResponse {
  responseResult: ResponseStatus
  usersCount: Int
  groupsCount: Int
  failed: [SystemImportUsersResponseFailed]
}

type SystemImportUsersResponseFailed {
  provider: String
  email: String
  error: String
}

type SystemExtension {
  key: String!
  title: String!
  description: String!
  isInstalled: Boolean!
  isCompatible: Boolean!
}

type SystemExportStatus {
  status: String
  progress: Int
  message: String
  startedAt: Date
}

type GeoProvince {
  label: String
  value: String
}

type GeoWorkWeek {
  start: Int
  end: Int
}

type GeoHris {
  enabled: Boolean
}

type GeoCreditScore {
  enabled: Boolean
}

type GeoCountryData {
  label: String
  value: String
  emoji: String
  dialCode: [String]
  currencies: [String]
  subtype: String
  abbreviation: String
  defaultCurrency: String
  defaultState: String
  provinces: [GeoProvince]
  workWeek: GeoWorkWeek
  hasCardDelivery: Boolean
  thirdPartyPaymentSupport: [String]
  continent: String
  hris: GeoHris
  creditScore: GeoCreditScore
  timezones: [String]
}

type DataTablesQuery {
  list: [DataTable!]!
  getTables: [DataTable!]!
  getTableContentByTableId(tableId: Int!): [DataTableContent]
  getTableContentById(id: Int!): String
}

type DataTable {
  id: Int!
  name: String!
  createdAt: Date!
  dataTablesContent: [DataTableContent]
  isLocked: Boolean!
  isOutSource: Boolean!
  pagesCount: Int!
}

type DataTableContent {
  id: Int!
  key: String!
  value: String!
  dataTablesContentPages: [DataTableContentPages]
}

type DataTableContentPages {
  id: Int!
  path: String!
}

type DataTablesMutation {
  create(name: String!, existingTable: Int): DefaultResponse!
  createFromCsv(path: String!, csv: String!): DefaultResponse!
  delete(tableId: Int!): DefaultResponse!
  deleteMany(ids: [Int!]): DefaultResponse!
  insertContent(tableId: Int!, key: String!, value: String!): DefaultResponse!
  updateNameById(tableId: Int!, name: String!): DefaultResponse!
  updateContentById(
    contentId: Int!
    key: String!
    value: String!
  ): DefaultResponse
  deleteContentById(contentId: Int!): DefaultResponse
}

type TagQuery {
  tagsWithCategories: [ShortTag!]!
  tagsByCategoryId(categoryId: Int!): [TagsByCategory!]!
  getSuggestedTagsByContent(content: String!): [String!]!
}

type Category {
  id: Int!
  name: String!
  slug: String!
}

type ShortTag {
  id: Int!
  tag: String!
  title: String
  categories: [Category!]!
  children: [TagsByCategory]!
}

type TagsByCategory {
  id: Int!
  tag: String!
  title: String
}

type TagCategoryQuery {
  list: [TagCategory!]!
  search(search: String): [TagCategoryWithTags!]!
}

type TagCategoryMutation {
  create(name: String!, slug: String!, published: Boolean!): DefaultResponse!
  update(
    id: Int!
    name: String!
    slug: String!
    published: Boolean!
    tags: [Int!]
  ): DefaultResponse!
  delete(id: Int!): DefaultResponse!
  updatePositions(orderedCategories: [UpdatedPositionType!]!): DefaultResponse!
}

input UpdatedPositionType {
  position: Int!
  id: Int!
}

type TagLibrariesQuery {
  list: [TagLibrary]!
  all: [TagLibrary]!
}

type TagLibrariesMutation {
  create(
    title: String!
    tags: [Int!]!
    groups: [Int!]
    published: Boolean!
    operator: String!
  ): DefaultResponse
  edit(
    id: Int!
    title: String!
    tags: [Int!]!
    groups: [Int!]
    published: Boolean!
    operator: String!
  ): DefaultResponse
  delete(id: Int!): DefaultResponse
}

type TagLibrary {
  id: Int!
  title: String!
  tags: [Int!]!
  groups: [Int!]
  published: Boolean!
  operator: String!
}

type ThemingQuery {
  themes: [ThemingTheme]
  config: ThemingConfig
  injected: InjectedTheme
}

type ThemingMutation {
  setConfig(
    theme: String!
    iconset: String!
    darkMode: Boolean!
    tocPosition: String
    injectCSS: String
    injectHead: String
    injectBody: String
  ): DefaultResponse
}

type ThemingConfig {
  theme: String!
  iconset: String!
  darkMode: Boolean!
  tocPosition: String
  injectCSS: String
  injectHead: String
  injectBody: String
}

type ThemingTheme {
  key: String
  title: String
  author: String
}

type InjectedTheme {
  injectCSS: String
  injectHead: String
  injectBody: String
}

type UserQuery {
  list(filter: String, orderBy: String): [UserMinimal]
  search(query: String!): [UserMinimal]
  searchStartsWith(query: String!): [UserMinimal]
  searchPageOwner(query: String!): [UserMinimal]
  single(id: Int!): User
  getUserPublicInfo(id: Int!): UserPublicInfo
  profile: UserProfile
  lastLogins: [UserLastLogin]
  getUserArticleMentions(
    cursor: String
    search: String
    pageLimit: Int
    userId: Int
  ): UserMentionResponse
}

type UserMutation {
  create(
    email: String!
    name: String!
    passwordRaw: String
    providerKey: String!
    groups: [Int]!
    mustChangePassword: Boolean
    sendWelcomeEmail: Boolean
  ): UserResponse
  update(
    id: Int!
    email: String
    name: String
    newPassword: String
    groups: [Int]
    location: String
    jobTitle: String
    timezone: String
    dateFormat: String
    appearance: String
  ): DefaultResponse
  delete(id: Int!, replaceId: Int!): DefaultResponse
  verify(id: Int!): DefaultResponse
  activate(id: Int!): DefaultResponse
  deactivate(id: Int!): DefaultResponse
  enableTFA(id: Int!): DefaultResponse
  disableTFA(id: Int!): DefaultResponse
  resetPassword(id: Int!): DefaultResponse
  updateProfile(
    name: String!
    location: String!
    jobTitle: String!
    timezone: String!
    dateFormat: String!
    appearance: String!
    defaultEditor: String
  ): UserTokenResponse
  changePassword(current: String!, new: String!): UserTokenResponse
}

type UserResponse {
  responseResult: ResponseStatus!
  user: User
}

type UserLastLogin {
  id: Int!
  name: String!
  lastLoginAt: Date!
}

type UserPublicInfo {
  pictureUrl: String
}

type UserMinimal {
  id: Int!
  name: String!
  email: String!
  providerKey: String!
  isSystem: Boolean!
  isActive: Boolean!
  createdAt: Date!
  lastLoginAt: Date
  pictureUrl: String
}

type User {
  id: Int!
  name: String!
  email: String!
  providerKey: String!
  providerName: String
  providerId: String
  providerIs2FACapable: Boolean
  isSystem: Boolean!
  isActive: Boolean!
  isVerified: Boolean!
  location: String!
  jobTitle: String!
  timezone: String!
  dateFormat: String!
  appearance: String!
  createdAt: Date!
  updatedAt: Date!
  lastLoginAt: Date
  tfaIsActive: Boolean!
  groups: [Group]!
  permissions: [String!]!
}

type ProfileGroup {
  id: Int!
  name: String!
  permissions: [String!]!
}

type UserProfile {
  id: Int!
  name: String!
  email: String!
  providerKey: String
  providerName: String
  isSystem: Boolean!
  isVerified: Boolean!
  location: String!
  jobTitle: String!
  timezone: String!
  dateFormat: String!
  appearance: String!
  defaultEditor: String
  createdAt: Date!
  updatedAt: Date!
  lastLoginAt: Date
  groups: [ProfileGroup]!
  pagesTotal: Int!
}

type UserTokenResponse {
  responseResult: ResponseStatus!
  jwt: String
}

type Mention {
  id: Int!
  pageId: Int!
  pageTitle: String!
  mentionId: String!
  mentionAt: Date!
}

type UserMentionResponse {
  cursor: String
  totalMentions: Int!
  totalArticleMentions: Int!
  currentQueryCount: Int!
  mentions: [Mention]!
}

type UserSettingsQuery {
  getByKey(key: String!): UserSettingResponse
  listSettings: [UserSettingResponse]!
  listHideNotificationSettings: [NotificationSettingsResponse]!
}

type UserSettingsMutation {
  insertSetting(key: String!, value: String!): ResponseStatus
  deleteSetting(key: String!): ResponseStatus
}

type UserSettingResponse {
  id: Int
  key: String
  value: String
  responseResult: ResponseStatus
}

type NotificationSettingsResponse {
  id: Int
  name: String
  label: String
  enabled: Boolean
  responseResult: ResponseStatus
}
